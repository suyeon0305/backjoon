//더하기 사이클
/* 
0보다 크거나 같고, 99보다 작거나 같은 정수가 주어질 때
주어진 수가 10보다 작다면, 앞에 0을 붙여 두자리 수로 만든다.
이렇게 주어진 두자리 수가 있을 때 각자리 숫자를 더한다.
그다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 
가장 오른쪽 자리수를 이어 붙이면 새로운 수가 만들어진다.
<예시>
26 -> 2+6 = 8 -> 68 -> 6+8 = 14 -> 84 -> 8+4 = 12 -> 42 -> 4+2 = 6 -> 26
총 네번만에 다시 원래 숫자로 돌아왔다.

이처럼 계산하면 몇번만에 원래 숫자로 돌아오는지 구하는 프로그램
*/
// 시작: 14:00 종료 14:20
#define _CRT_NO_SECURE_WARNINGS
#include <stdio.h>

int main() {
    int n_org, n;
    int n10, n1;
    int cnt=0;

    scanf("%d", &n_org);
    n = n_org;
    do
    {
        n10 = (n_org%10)*10;
        n1 = ((n_org/10) + (n_org%10)) %10;
        n_org = n10+n1;
        cnt++;
    } while (n != n_org);
    printf("%d", cnt);
}


/*
계산하는 문제를 한번만에 짠 코드로 성공한적은 처음이다ㅜㅜ
매일한 보람이 있는것같아서 너무 뿌듯하고 기분이 좋다ㅠ

이문제는 입력한 값 n을 어떻게 분할하고, 더해주는지, 그리고 어떤 것이 반복되는지 찾는게 중요했다.
do-while 구문을 사용하여 같은 값이 나올 때까지 받도록 했다.
n_org을 입력받고, n에 그값을 그대로 저장하여 비교할 수 있도록 했다.
*/